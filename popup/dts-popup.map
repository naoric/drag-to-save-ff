{"version":3,"sources":["../node_modules/lit-html/lit-html.js","../node_modules/lit-html/lib/lit-extended.js","dts-popup.tsx"],"names":["defaultTemplateFactory","render","templateCaches","Map","html","strings","values","TemplateResult","svg","SVGTemplateResult","type","partCallback","defaultPartCallback","l","length","isTextBinding","i","s","closing","findTagClose","nodeMarker","marker","template","document","createElement","innerHTML","getHTML","getTemplateElement","content","svgElement","firstChild","removeChild","result","templateCache","get","undefined","set","Template","container","templateFactory","instance","__templateInstance","_partCallback","update","TemplateInstance","fragment","_clone","appendChild","String","Math","random","slice","markerRegex","RegExp","lastAttributeNameRegex","str","close","lastIndexOf","open","indexOf","TemplatePart","index","name","rawName","isTemplatePartActive","part","element","parts","walker","createTreeWalker","partIndex","nodesToRemove","previousNode","currentNode","nextNode","node","nodeType","hasAttributes","attributes","count","value","stringForPart","attributeNameInPart","exec","attribute","getNamedItem","stringsForAttributeValue","split","push","removeAttribute","nodeValue","parent","parentNode","lastIndex","insertBefore","createComment","createTextNode","previousSibling","Node","TEXT_NODE","nextSibling","n","getValue","isDirective","noChange","directive","f","__litDirective","o","directiveValue","isPrimitiveValue","AttributePart","size","_previousValues","startIndex","text","v","Array","isArray","Symbol","iterator","t","_equalToPreviousValues","join","_interpolate","setAttribute","NodePart","startNode","endNode","_previousValue","_setText","_setTemplateResult","_setIterable","_setNode","then","_setPromise","clear","_insert","textContent","_getTemplate","itemParts","item","itemPart","itemStart","previousPart","setValue","lastPart","templatePart","Error","getTemplate","_parts","valueIndex","cloneNode","partActive","reparentNodes","start","end","before","removeNodes","extendedPartCallback","substr","eventName","EventPart","lastChar","BooleanAttributePart","PropertyPart","listener","_listener","removeEventListener","addEventListener","event","call","handleEvent"],"mappings":"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","file":"dts-popup.map","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// The first argument to JS template tags retain identity across multiple\n// calls to a tag for the same literal, so we can cache work done per literal\n// in a Map.\nexport const templateCaches = new Map();\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings, ...values) => new TemplateResult(strings, values, 'html');\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg');\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(strings, values, type, partCallback = defaultPartCallback) {\n        this.strings = strings;\n        this.values = values;\n        this.type = type;\n        this.partCallback = partCallback;\n    }\n    /**\n     * Returns a string of HTML used to create a <template> element.\n     */\n    getHTML() {\n        const l = this.strings.length - 1;\n        let html = '';\n        let isTextBinding = true;\n        for (let i = 0; i < l; i++) {\n            const s = this.strings[i];\n            html += s;\n            // We're in a text position if the previous string closed its tags.\n            // If it doesn't have any tags, then we use the previous text position\n            // state.\n            const closing = findTagClose(s);\n            isTextBinding = closing > -1 ? closing < s.length : isTextBinding;\n            html += isTextBinding ? nodeMarker : marker;\n        }\n        html += this.strings[l];\n        return html;\n    }\n    getTemplateElement() {\n        const template = document.createElement('template');\n        template.innerHTML = this.getHTML();\n        return template;\n    }\n}\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTMl in an <svg> tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the <svg> tag so that\n * clones only container the original fragment.\n */\nexport class SVGTemplateResult extends TemplateResult {\n    getHTML() {\n        return `<svg>${super.getHTML()}</svg>`;\n    }\n    getTemplateElement() {\n        const template = super.getTemplateElement();\n        const content = template.content;\n        const svgElement = content.firstChild;\n        content.removeChild(svgElement);\n        reparentNodes(content, svgElement.firstChild);\n        return template;\n    }\n}\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nexport function defaultTemplateFactory(result) {\n    let templateCache = templateCaches.get(result.type);\n    if (templateCache === undefined) {\n        templateCache = new Map();\n        templateCaches.set(result.type, templateCache);\n    }\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n        template = new Template(result, result.getTemplateElement());\n        templateCache.set(result.strings, template);\n    }\n    return template;\n}\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result a TemplateResult created by evaluating a template tag like\n *     `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param templateFactory a function to create a Template or retreive one from\n *     cache.\n */\nexport function render(result, container, templateFactory = defaultTemplateFactory) {\n    const template = templateFactory(result);\n    let instance = container.__templateInstance;\n    // Repeat render, just call update()\n    if (instance !== undefined && instance.template === template &&\n        instance._partCallback === result.partCallback) {\n        instance.update(result.values);\n        return;\n    }\n    // First render, create a new TemplateInstance and append it\n    instance =\n        new TemplateInstance(template, result.partCallback, templateFactory);\n    container.__templateInstance = instance;\n    const fragment = instance._clone();\n    instance.update(result.values);\n    removeNodes(container, container.firstChild);\n    container.appendChild(fragment);\n}\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nconst marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, not attribute positions,\n * in template.\n */\nconst nodeMarker = `<!--${marker}-->`;\nconst markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#attributes-0\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-character\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst lastAttributeNameRegex = /[ \\x09\\x0a\\x0c\\x0d]([^\\0-\\x1F\\x7F-\\x9F \\x09\\x0a\\x0c\\x0d\"'>=/]+)[ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*)$/;\n/**\n * Finds the closing index of the last closed HTML tag.\n * This has 3 possible return values:\n *   - `-1`, meaning there is no tag in str.\n *   - `string.length`, meaning the last opened tag is unclosed.\n *   - Some positive number < str.length, meaning the index of the closing '>'.\n */\nfunction findTagClose(str) {\n    const close = str.lastIndexOf('>');\n    const open = str.indexOf('<', close + 1);\n    return open > -1 ? str.length : close;\n}\n/**\n * A placeholder for a dynamic expression in an HTML template.\n *\n * There are two built-in part types: AttributePart and NodePart. NodeParts\n * always represent a single dynamic expression, while AttributeParts may\n * represent as many expressions are contained in the attribute.\n *\n * A Template's parts are mutable, so parts can be replaced or modified\n * (possibly to implement different template semantics). The contract is that\n * parts can only be replaced, not removed, added or reordered, and parts must\n * always consume the correct number of values in their `update()` method.\n *\n * TODO(justinfagnani): That requirement is a little fragile. A\n * TemplateInstance could instead be more careful about which values it gives\n * to Part.update().\n */\nexport class TemplatePart {\n    constructor(type, index, name, rawName, strings) {\n        this.type = type;\n        this.index = index;\n        this.name = name;\n        this.rawName = rawName;\n        this.strings = strings;\n    }\n}\nexport const isTemplatePartActive = (part) => part.index !== -1;\n/**\n * An updateable Template that tracks the location of dynamic parts.\n */\nexport class Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        const content = this.element.content;\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n               NodeFilter.SHOW_TEXT */, null, false);\n        let index = -1;\n        let partIndex = 0;\n        const nodesToRemove = [];\n        // The actual previous node, accounting for removals: if a node is removed\n        // it will never be the previousNode.\n        let previousNode;\n        // Used to set previousNode at the top of the loop.\n        let currentNode;\n        while (walker.nextNode()) {\n            index++;\n            previousNode = currentNode;\n            const node = currentNode = walker.currentNode;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (!node.hasAttributes()) {\n                    continue;\n                }\n                const attributes = node.attributes;\n                // Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                // attributes are not guaranteed to be returned in document order. In\n                // particular, Edge/IE can return them out of order, so we cannot assume\n                // a correspondance between part index and attribute index.\n                let count = 0;\n                for (let i = 0; i < attributes.length; i++) {\n                    if (attributes[i].value.indexOf(marker) >= 0) {\n                        count++;\n                    }\n                }\n                while (count-- > 0) {\n                    // Get the template literal section leading up to the first\n                    // expression in this attribute\n                    const stringForPart = result.strings[partIndex];\n                    // Find the attribute name\n                    const attributeNameInPart = lastAttributeNameRegex.exec(stringForPart)[1];\n                    // Find the corresponding attribute\n                    // TODO(justinfagnani): remove non-null assertion\n                    const attribute = attributes.getNamedItem(attributeNameInPart);\n                    const stringsForAttributeValue = attribute.value.split(markerRegex);\n                    this.parts.push(new TemplatePart('attribute', index, attribute.name, attributeNameInPart, stringsForAttributeValue));\n                    node.removeAttribute(attribute.name);\n                    partIndex += stringsForAttributeValue.length - 1;\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const nodeValue = node.nodeValue;\n                if (nodeValue.indexOf(marker) < 0) {\n                    continue;\n                }\n                const parent = node.parentNode;\n                const strings = nodeValue.split(markerRegex);\n                const lastIndex = strings.length - 1;\n                // We have a part for each match found\n                partIndex += lastIndex;\n                // Generate a new text node for each literal section\n                // These nodes are also used as the markers for node parts\n                for (let i = 0; i < lastIndex; i++) {\n                    parent.insertBefore((strings[i] === '')\n                        ? document.createComment('')\n                        : document.createTextNode(strings[i]), node);\n                    this.parts.push(new TemplatePart('node', index++));\n                }\n                parent.insertBefore(strings[lastIndex] === '' ?\n                    document.createComment('') :\n                    document.createTextNode(strings[lastIndex]), node);\n                nodesToRemove.push(node);\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */ &&\n                node.nodeValue === marker) {\n                const parent = node.parentNode;\n                // Add a new marker node to be the startNode of the Part if any of the\n                // following are true:\n                //  * We don't have a previousSibling\n                //  * previousSibling is being removed (thus it's not the\n                //    `previousNode`)\n                //  * previousSibling is not a Text node\n                //\n                // TODO(justinfagnani): We should be able to use the previousNode here\n                // as the marker node and reduce the number of extra nodes we add to a\n                // template. See https://github.com/PolymerLabs/lit-html/issues/147\n                const previousSibling = node.previousSibling;\n                if (previousSibling === null || previousSibling !== previousNode ||\n                    previousSibling.nodeType !== Node.TEXT_NODE) {\n                    parent.insertBefore(document.createComment(''), node);\n                }\n                else {\n                    index--;\n                }\n                this.parts.push(new TemplatePart('node', index++));\n                nodesToRemove.push(node);\n                // If we don't have a nextSibling add a marker node.\n                // We don't have to check if the next node is going to be removed,\n                // because that node will induce a new marker if so.\n                if (node.nextSibling === null) {\n                    parent.insertBefore(document.createComment(''), node);\n                }\n                else {\n                    index--;\n                }\n                currentNode = previousNode;\n                partIndex++;\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\n/**\n * Returns a value ready to be inserted into a Part from a user-provided value.\n *\n * If the user value is a directive, this invokes the directive with the given\n * part. If the value is null, it's converted to undefined to work better\n * with certain DOM APIs, like textContent.\n */\nexport const getValue = (part, value) => {\n    // `null` as the value of a Text node will render the string 'null'\n    // so we convert it to undefined\n    if (isDirective(value)) {\n        value = value(part);\n        return noChange;\n    }\n    return value === null ? undefined : value;\n};\nexport const directive = (f) => {\n    f.__litDirective = true;\n    return f;\n};\nconst isDirective = (o) => typeof o === 'function' && o.__litDirective === true;\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = {};\n/**\n * @deprecated Use `noChange` instead.\n */\nexport { noChange as directiveValue };\nconst isPrimitiveValue = (value) => value === null ||\n    !(typeof value === 'object' || typeof value === 'function');\nexport class AttributePart {\n    constructor(instance, element, name, strings) {\n        this.instance = instance;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.size = strings.length - 1;\n        this._previousValues = [];\n    }\n    _interpolate(values, startIndex) {\n        const strings = this.strings;\n        const l = strings.length - 1;\n        let text = '';\n        for (let i = 0; i < l; i++) {\n            text += strings[i];\n            const v = getValue(this, values[startIndex + i]);\n            if (v && v !== noChange &&\n                (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n                for (const t of v) {\n                    // TODO: we need to recursively call getValue into iterables...\n                    text += t;\n                }\n            }\n            else {\n                text += v;\n            }\n        }\n        return text + strings[l];\n    }\n    _equalToPreviousValues(values, startIndex) {\n        for (let i = startIndex; i < startIndex + this.size; i++) {\n            if (this._previousValues[i] !== values[i] ||\n                !isPrimitiveValue(values[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    setValue(values, startIndex) {\n        if (this._equalToPreviousValues(values, startIndex)) {\n            return;\n        }\n        const s = this.strings;\n        let value;\n        if (s.length === 2 && s[0] === '' && s[1] === '') {\n            // An expression that occupies the whole attribute value will leave\n            // leading and trailing empty strings.\n            value = getValue(this, values[startIndex]);\n            if (Array.isArray(value)) {\n                value = value.join('');\n            }\n        }\n        else {\n            value = this._interpolate(values, startIndex);\n        }\n        if (value !== noChange) {\n            this.element.setAttribute(this.name, value);\n        }\n        this._previousValues = values;\n    }\n}\nexport class NodePart {\n    constructor(instance, startNode, endNode) {\n        this.instance = instance;\n        this.startNode = startNode;\n        this.endNode = endNode;\n        this._previousValue = undefined;\n    }\n    setValue(value) {\n        value = getValue(this, value);\n        if (value === noChange) {\n            return;\n        }\n        if (isPrimitiveValue(value)) {\n            // Handle primitive values\n            // If the value didn't change, do nothing\n            if (value === this._previousValue) {\n                return;\n            }\n            this._setText(value);\n        }\n        else if (value instanceof TemplateResult) {\n            this._setTemplateResult(value);\n        }\n        else if (Array.isArray(value) || value[Symbol.iterator]) {\n            this._setIterable(value);\n        }\n        else if (value instanceof Node) {\n            this._setNode(value);\n        }\n        else if (value.then !== undefined) {\n            this._setPromise(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._setText(value);\n        }\n    }\n    _insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    _setNode(value) {\n        if (this._previousValue === value) {\n            return;\n        }\n        this.clear();\n        this._insert(value);\n        this._previousValue = value;\n    }\n    _setText(value) {\n        const node = this.startNode.nextSibling;\n        value = value === undefined ? '' : value;\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === Node.TEXT_NODE) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if _previousValue is\n            // primitive?\n            node.textContent = value;\n        }\n        else {\n            this._setNode(document.createTextNode(value));\n        }\n        this._previousValue = value;\n    }\n    _setTemplateResult(value) {\n        const template = this.instance._getTemplate(value);\n        let instance;\n        if (this._previousValue && this._previousValue.template === template) {\n            instance = this._previousValue;\n        }\n        else {\n            instance = new TemplateInstance(template, this.instance._partCallback, this.instance._getTemplate);\n            this._setNode(instance._clone());\n            this._previousValue = instance;\n        }\n        instance.update(value.values);\n    }\n    _setIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _previousValue is an array, then the previous render was of an\n        // iterable and _previousValue will contain the NodeParts from the previous\n        // render. If _previousValue is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this._previousValue)) {\n            this.clear();\n            this._previousValue = [];\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this._previousValue;\n        let partIndex = 0;\n        for (const item of value) {\n            // Try to reuse an existing part\n            let itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                // If we're creating the first item part, it's startNode should be the\n                // container's startNode\n                let itemStart = this.startNode;\n                // If we're not creating the first part, create a new separator marker\n                // node, and fix up the previous part's endNode to point to it\n                if (partIndex > 0) {\n                    const previousPart = itemParts[partIndex - 1];\n                    itemStart = previousPart.endNode = document.createTextNode('');\n                    this._insert(itemStart);\n                }\n                itemPart = new NodePart(this.instance, itemStart, this.endNode);\n                itemParts.push(itemPart);\n            }\n            itemPart.setValue(item);\n            partIndex++;\n        }\n        if (partIndex === 0) {\n            this.clear();\n            this._previousValue = undefined;\n        }\n        else if (partIndex < itemParts.length) {\n            const lastPart = itemParts[partIndex - 1];\n            // Truncate the parts array so _previousValue reflects the current state\n            itemParts.length = partIndex;\n            this.clear(lastPart.endNode.previousSibling);\n            lastPart.endNode = this.endNode;\n        }\n    }\n    _setPromise(value) {\n        this._previousValue = value;\n        value.then((v) => {\n            if (this._previousValue === value) {\n                this.setValue(v);\n            }\n        });\n    }\n    clear(startNode = this.startNode) {\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n}\nexport const defaultPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        return new AttributePart(instance, node, templatePart.name, templatePart.strings);\n    }\n    else if (templatePart.type === 'node') {\n        return new NodePart(instance, node, node.nextSibling);\n    }\n    throw new Error(`Unknown part type ${templatePart.type}`);\n};\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n    constructor(template, partCallback, getTemplate) {\n        this._parts = [];\n        this.template = template;\n        this._partCallback = partCallback;\n        this._getTemplate = getTemplate;\n    }\n    update(values) {\n        let valueIndex = 0;\n        for (const part of this._parts) {\n            if (!part) {\n                valueIndex++;\n            }\n            else if (part.size === undefined) {\n                part.setValue(values[valueIndex]);\n                valueIndex++;\n            }\n            else {\n                part.setValue(values, valueIndex);\n                valueIndex += part.size;\n            }\n        }\n    }\n    _clone() {\n        // Clone the node, rather than importing it, to keep the fragment in the\n        // template's document. This leaves the fragment inert so custom elements\n        // won't upgrade until after the main document adopts the node.\n        const fragment = this.template.element.content.cloneNode(true);\n        const parts = this.template.parts;\n        if (parts.length > 0) {\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n                   NodeFilter.SHOW_TEXT */, null, false);\n            let index = -1;\n            for (let i = 0; i < parts.length; i++) {\n                const part = parts[i];\n                const partActive = isTemplatePartActive(part);\n                // An inactive part has no coresponding Template node.\n                if (partActive) {\n                    while (index < part.index) {\n                        index++;\n                        walker.nextNode();\n                    }\n                }\n                this._parts.push(partActive ? this._partCallback(this, part, walker.currentNode) : undefined);\n            }\n        }\n        return fragment;\n    }\n}\n/**\n * Reparents nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), into another container (could be the same container), before\n * `beforeNode`. If `beforeNode` is null, it appends the nodes to the\n * container.\n */\nexport const reparentNodes = (container, start, end = null, before = null) => {\n    let node = start;\n    while (node !== end) {\n        const n = node.nextSibling;\n        container.insertBefore(node, before);\n        node = n;\n    }\n};\n/**\n * Removes nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), from `container`.\n */\nexport const removeNodes = (container, startNode, endNode = null) => {\n    let node = startNode;\n    while (node !== endNode) {\n        const n = node.nextSibling;\n        container.removeChild(node);\n        node = n;\n    }\n};\n//# sourceMappingURL=lit-html.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributePart, defaultPartCallback, noChange, getValue, SVGTemplateResult, TemplateResult } from '../lit-html.js';\nexport { render } from '../lit-html.js';\n/**\n * Interprets a template literal as a lit-extended HTML template.\n */\nexport const html = (strings, ...values) => new TemplateResult(strings, values, 'html', extendedPartCallback);\n/**\n * Interprets a template literal as a lit-extended SVG template.\n */\nexport const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', extendedPartCallback);\n/**\n * A PartCallback which allows templates to set properties and declarative\n * event handlers.\n *\n * Properties are set by default, instead of attributes. Attribute names in\n * lit-html templates preserve case, so properties are case sensitive. If an\n * expression takes up an entire attribute value, then the property is set to\n * that value. If an expression is interpolated with a string or other\n * expressions then the property is set to the string result of the\n * interpolation.\n *\n * To set an attribute instead of a property, append a `$` suffix to the\n * attribute name.\n *\n * Example:\n *\n *     html`<button class$=\"primary\">Buy Now</button>`\n *\n * To set an event handler, prefix the attribute name with `on-`:\n *\n * Example:\n *\n *     html`<button on-click=${(e)=> this.onClickHandler(e)}>Buy Now</button>`\n *\n */\nexport const extendedPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        if (templatePart.rawName.substr(0, 3) === 'on-') {\n            const eventName = templatePart.rawName.slice(3);\n            return new EventPart(instance, node, eventName);\n        }\n        const lastChar = templatePart.name.substr(templatePart.name.length - 1);\n        if (lastChar === '$') {\n            const name = templatePart.name.slice(0, -1);\n            return new AttributePart(instance, node, name, templatePart.strings);\n        }\n        if (lastChar === '?') {\n            const name = templatePart.name.slice(0, -1);\n            return new BooleanAttributePart(instance, node, name, templatePart.strings);\n        }\n        return new PropertyPart(instance, node, templatePart.rawName, templatePart.strings);\n    }\n    return defaultPartCallback(instance, templatePart, node);\n};\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart extends AttributePart {\n    setValue(values, startIndex) {\n        const s = this.strings;\n        if (s.length === 2 && s[0] === '' && s[1] === '') {\n            const value = getValue(this, values[startIndex]);\n            if (value === noChange) {\n                return;\n            }\n            if (value) {\n                this.element.setAttribute(this.name, '');\n            }\n            else {\n                this.element.removeAttribute(this.name);\n            }\n        }\n        else {\n            throw new Error('boolean attributes can only contain a single expression');\n        }\n    }\n}\nexport class PropertyPart extends AttributePart {\n    setValue(values, startIndex) {\n        const s = this.strings;\n        let value;\n        if (this._equalToPreviousValues(values, startIndex)) {\n            return;\n        }\n        if (s.length === 2 && s[0] === '' && s[1] === '') {\n            // An expression that occupies the whole attribute value will leave\n            // leading and trailing empty strings.\n            value = getValue(this, values[startIndex]);\n        }\n        else {\n            // Interpolation, so interpolate\n            value = this._interpolate(values, startIndex);\n        }\n        if (value !== noChange) {\n            this.element[this.name] = value;\n        }\n        this._previousValues = values;\n    }\n}\nexport class EventPart {\n    constructor(instance, element, eventName) {\n        this.instance = instance;\n        this.element = element;\n        this.eventName = eventName;\n    }\n    setValue(value) {\n        const listener = getValue(this, value);\n        if (listener === this._listener) {\n            return;\n        }\n        if (listener == null) {\n            this.element.removeEventListener(this.eventName, this);\n        }\n        else if (this._listener == null) {\n            this.element.addEventListener(this.eventName, this);\n        }\n        this._listener = listener;\n    }\n    handleEvent(event) {\n        if (typeof this._listener === 'function') {\n            this._listener.call(this.element, event);\n        }\n        else if (typeof this._listener.handleEvent === 'function') {\n            this._listener.handleEvent(event);\n        }\n    }\n}\n//# sourceMappingURL=lit-extended.js.map","import { html, render } from 'lit-html/lib/lit-extended';\ndeclare var browser: any;\n\nconst s = (sel: string) => document.querySelector(sel);\nconst sa = (sel: string) => document.querySelectorAll(sel);\n\ninterface LinkItem {\n  link: string;\n  title: string;\n}\n\ninterface ListItemProps {\n  item: LinkItem;\n  del: () => void;\n}\n\ninterface ListProps {\n  items: LinkItem[];\n  clicked: (idx: number) => void;\n  clear: () => void;\n  clipboard: () => void;\n}\n\ninterface LinkStorage {\n  links: LinkItem[];\n}\n\nfunction ListItem(props: ListItemProps) {\n  return html`\n<li class=\"lc-item\">\n<a href=\"${props.item.link}\" class=\"lc-link\" target=\"_blank\">\n<span class=\"lc-title\">${props.item.title}</span>\n<i href=\"\" class=\"lc-checked fas fa-trash\" onclick=${(e: any) => {\n    e.preventDefault();\n    props.del();\n  }}></i>\n</a>\n</li>\n`;\n}\n\nfunction List(props: ListProps) {\n  return html`\n<ul class=\"lc-list\">\n${props.items.map((ln, idx) =>\n    ListItem({ item: ln, del: () => props.clicked(idx) })\n  )}\n</ul>\n<div class=\"lc-actions\">\n<button class=\"lc-clipboard lc-btn-basic\" onclick=${\n    props.clipboard\n  }>Copy All</button>\n<button class=\"lc-clear lc-btn-basic\" onclick=${props.clear}>Clear</button>\n</div>\n`;\n}\n\nbrowser.storage.sync.get({ links: [] }, (res: LinkStorage) =>\n  update(res.links)\n);\n\nbrowser.storage.onChanged.addListener(\n  (values: { links: { newValue: LinkItem[] } }) => update(values.links.newValue)\n);\n\nconst container = getContainer()!;\ndocument.body.appendChild(container);\n\nfunction getContainer() {\n  return s('.lc-container');\n}\n\nfunction update(items: LinkItem[] = []) {\n  const clicked = (index: number) =>\n    browser.runtime.sendMessage({ type: 'remove-link', index });\n  const clipboard = () => {\n    const input: HTMLInputElement = s(\n      '.lc-clipboard-input'\n    ) as HTMLInputElement;\n    if (!input) {\n      return;\n    }\n    input.value = itemsToString(items);\n    input.select();\n    document.execCommand('copy');\n  };\n\n  const clear = () => browser.runtime.sendMessage({ type: 'clear-links' });\n\n  const template = List({ items, clicked, clear, clipboard });\n  render(template, container);\n}\n\nfunction itemsToString(items: LinkItem[]) {\n  return items.map(it => it.link).join('\\n');\n}\n"]}